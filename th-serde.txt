-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A serialization/deserialization framework for Haskell
--   
--   A lightweight serialization/deserialization framework for Haskell that
--   uses Template Haskell and QuasiQuotes to separate data structure
--   definitions from their serialization and validation logic. It
--   generates shadow types automatically and supports custom type class
--   derivation through coercion, reducing boilerplate while keeping
--   business logic clean.
--   
--   For more information, please refer to the README.md file at
--   <a>https://github.com/axionbuster/th-serde#readme</a>.
@package th-serde
@version 0.1.3.0


-- | intermediate syntax for the parser
--   
--   see <a>Data.Serde.Syn</a> for the grammar
module Data.Serde.Internal.ISyn
parsetop :: Parser (Derive, [ISyn])

-- | intermediate representation of type definitions parsed from the input
--   syntax. can be a data type, newtype, or type alias.
data ISyn
ISynData :: String -> [ISynFld] -> ISyn
[isnam] :: ISyn -> String
[isflds] :: ISyn -> [ISynFld]
ISynNewtype :: String -> INewtypePayload -> ISyn
[isnam] :: ISyn -> String
[isfld1] :: ISyn -> INewtypePayload
ISynAlias :: String -> String -> ISyn
[isnam] :: ISyn -> String
[isdest] :: ISyn -> String

-- | field definition for data types and newtypes, containing a field name
--   and its type information
data ISynFld
ISynFld :: String -> ViaInfo -> ISynFld
[isfldnam] :: ISynFld -> String
[isfldtyp] :: ISynFld -> ViaInfo

-- | payload for newtype definitions, which can either be a field with a
--   name and type, or just a type
data INewtypePayload
IField :: ISynFld -> INewtypePayload
IType :: ViaInfo -> INewtypePayload

-- | type information that may include a <tt>via</tt> clause
data ViaInfo
Plain :: String -> ViaInfo
WithVia :: String -> String -> ViaInfo

-- | collection of type classes to derive for all defined types
newtype Derive
Derive :: [String] -> Derive
[getderive] :: Derive -> [String]

-- | parser type for the intermediate syntax
type Parser = Parsec Void String
_testbody1 :: String
instance GHC.Show.Show Data.Serde.Internal.ISyn.Derive
instance GHC.Show.Show Data.Serde.Internal.ISyn.INewtypePayload
instance GHC.Show.Show Data.Serde.Internal.ISyn.ISyn
instance GHC.Show.Show Data.Serde.Internal.ISyn.ISynFld
instance GHC.Show.Show Data.Serde.Internal.ISyn.ViaInfo


-- | define syntax
module Data.Serde.Internal.Syn

-- | parsed data
data Parsed
Parsed :: [Syn] -> Derive -> Parsed
[declarations] :: Parsed -> [Syn]
[derives] :: Parsed -> Derive

-- | parse quasi-quoted syntax
parse :: String -> Either String Parsed

-- | go from type string to <tt>Exts</tt>.<a>Type</a>
--   
--   you need to use a function from <a>Data.Serde.Type</a> to convert this
--   to a TH.<a>Type</a>
parsetypeexts :: String -> Type

-- | a declaration
data Syn
SynData :: Name -> [SynFld] -> [Name] -> Syn
[synnam] :: Syn -> Name
[synflds] :: Syn -> [SynFld]
[synders] :: Syn -> [Name]
SynNewtype :: Name -> Either ViaInfo SynFld -> [Name] -> Syn
[synnam] :: Syn -> Name
[synfld] :: Syn -> Either ViaInfo SynFld
[synders] :: Syn -> [Name]
SynAlias :: Name -> Type -> Syn
[synnam] :: Syn -> Name
[syndest] :: Syn -> Type

-- | field information
data SynFld
SynFld :: Name -> Type -> Maybe Type -> SynFld
[synfnam] :: SynFld -> Name
[synftyp] :: SynFld -> Type
[synfvia] :: SynFld -> Maybe Type

-- | type information that may include a <tt>via</tt> clause
data ViaInfo
Plain :: String -> ViaInfo
WithVia :: String -> String -> ViaInfo
type Name = Name ()
type Type = Type ()
instance GHC.Show.Show Data.Serde.Internal.Syn.Parsed
instance GHC.Show.Show Data.Serde.Internal.Syn.Syn
instance GHC.Show.Show Data.Serde.Internal.Syn.SynFld


-- | conversion of <a>Type</a> to <a>Type</a>
module Data.Serde.Internal.Type

-- | convert a <a>Type</a> to a <a>Type</a>
class ToTH a

-- | convert a <a>Type</a> to a <a>Type</a>
toth :: ToTH a => a -> Type

-- | convert a Exts.<a>Name</a> to a TH.<a>Name</a>
--   
--   qualification gets handled syntactically
cvtnam :: Name -> Name

-- | convert a <a>Derive</a> to a list of TH.<a>Type</a>s
cvtder :: Derive -> [Type]
instance Data.Serde.Internal.Type.ToTH Language.Haskell.Exts.Simple.Syntax.Type


-- | template Haskell generator
module Data.Serde.Internal.TH

-- | run quasi-quote body, and replace Q state (to get the shadowable data
--   types)
runqq1 :: String -> Q [Dec]

-- | using the stored state (from last quasi-quote run), run user code to
--   generate coercions
runusercoercion :: (RunUserCoercion -> Q [Dec]) -> (Name -> Q [Dec]) -> [Name] -> Q [Dec]

-- | arguments to user code that generates coercions
data RunUserCoercion
RunUserCoercion :: Q Pat -> Q Pat -> Q Exp -> Q Exp -> Q Type -> Q Type -> RunUserCoercion

-- | regular (non-record syntax) pattern for deconstruction (normal)
[patnormal] :: RunUserCoercion -> Q Pat

-- | regular (non-record syntax) pattern for deconstruction (shadow)
[patshadow] :: RunUserCoercion -> Q Pat

-- | apply shadow fields to a normal constructor
[appnormal] :: RunUserCoercion -> Q Exp

-- | apply normal fields to a shadow constructor
[appshadow] :: RunUserCoercion -> Q Exp

-- | class to derive
[datatyp] :: RunUserCoercion -> Q Type

-- | shadow data type
[shadowdatatyp] :: RunUserCoercion -> Q Type


-- | The main stable interface for the th-serde library, providing
--   QuasiQuoters for defining data types with separated serialization and
--   validation logic. Other modules are considered internal and may change
--   without notice.
--   
--   <h1>Overview</h1>
--   
--   This library helps separate your core data models from their
--   serialization and validation logic. While newtypes are commonly used
--   for this purpose, they become unwieldy with complex data types,
--   especially when dealing with multiple fields that need validation or
--   custom serialization.
--   
--   <h1>How It Works</h1>
--   
--   Given a data type definition with 'via' annotations, th-serde:
--   
--   <ol>
--   <li>Generates your core data type with clean, simple fields</li>
--   <li>Creates a "shadow" type with the validation/serialization
--   wrappers</li>
--   <li>Provides machinery to convert between them using
--   <a>coerce</a></li>
--   </ol>
--   
--   Important: Shadow types are generated without any type class
--   implementations. You must implement all needed type classes for shadow
--   types using <tt>runuserprep</tt>. The QuasiQuoter never automatically
--   derives any instances for shadow types.
--   
--   <h1>Example</h1>
--   
--   Here's a complete example:
--   
--   <pre>
--   [serde|
--   .derive
--     Eq Ord Show Read
--   
--   -- Your core data type with validation annotations
--   -- Suppose Age, VerifyLength, and VerifyEmail are defined elsewhere
--   data Person
--     age :: Int32 via Age                     -- Validate using Age newtype
--     name :: String via VerifyLength 1 10     -- Must be 1-10 chars
--     email :: String via VerifyEmail          -- Must be valid email
--   |]
--   </pre>
--   
--   This generates:
--   
--   <pre>
--   -- Your clean business model
--   data Person = Person
--     { age :: Int32    -- Clean types without validation wrappers
--     , name :: String
--     , email :: String
--     } deriving (Eq, Ord, Show, Read)
--   
--   -- Auto-generated shadow type for validation
--   data Person__ = Person__
--     { age__ :: Age               -- Fields use validation wrappers
--     , name__ :: VerifyLength 1 10
--     , email__ :: VerifyEmail
--     }
--   </pre>
--   
--   <h1>Usage Pattern</h1>
--   
--   <ol>
--   <li>Define your types using the <a>serde</a> QuasiQuoter</li>
--   <li>Call <a>runusercoercion</a> to implement
--   validation/serialization</li>
--   </ol>
--   
--   <h1>Syntax Reference</h1>
--   
--   <h2>Deriving Classes</h2>
--   
--   Use <tt>.derive</tt> at the start to specify which classes to derive:
--   
--   <pre>
--   .derive
--     Eq Ord Show Read  -- These will be derived for all types except shadow types
--   </pre>
--   
--   <h2>Data Types</h2>
--   
--   <pre>
--   data Person                    -- Regular data type
--     field :: Type via Validator  -- Field with validation
--     plain :: Type                -- Field without validation
--   </pre>
--   
--   <h2>Newtypes</h2>
--   
--   Unlike data types, newtypes using <tt>via</tt> (either in field or
--   type position) will use GHC's <tt>DerivingVia</tt> mechanism directly
--   instead of creating shadow types. This requires the
--   <tt>DerivingVia</tt> language extension to be enabled.
--   
--   <pre>
--   newtype Age        -- Simple newtype without via
--     value :: Int32   -- Regular field, no shadow type created
--   
--   newtype Number Double
--   
--   newtype Validated Int32 via Check  -- With validation
--   -- ^ Generates:
--   --   newtype Validated = Validated Int32
--   --     deriving (...) via Check
--   
--   newtype Name       -- With record syntax + via
--     getName :: String via Verify
--   -- ^ Generates:
--   --   newtype Name = Name { getName :: String }
--   --     deriving (...) via Verify
--   </pre>
--   
--   <h2>Type Aliases</h2>
--   
--   Type aliases do not participate in the derivation process and are not
--   shadowed.
--   
--   <pre>
--   type EmailStr String
--   </pre>
--   
--   <h2>Examples</h2>
--   
--   Examples can be found in the test suite.
module Data.Serde.QQ

-- | quasi-quoter for th-serde
serde :: QuasiQuoter

-- | arguments to user code that generates coercions
data RunUserCoercion
RunUserCoercion :: Q Pat -> Q Pat -> Q Exp -> Q Exp -> Q Type -> Q Type -> RunUserCoercion

-- | regular (non-record syntax) pattern for deconstruction (normal)
[patnormal] :: RunUserCoercion -> Q Pat

-- | regular (non-record syntax) pattern for deconstruction (shadow)
[patshadow] :: RunUserCoercion -> Q Pat

-- | apply shadow fields to a normal constructor
[appnormal] :: RunUserCoercion -> Q Exp

-- | apply normal fields to a shadow constructor
[appshadow] :: RunUserCoercion -> Q Exp

-- | class to derive
[datatyp] :: RunUserCoercion -> Q Type

-- | shadow data type
[shadowdatatyp] :: RunUserCoercion -> Q Type

-- | using the stored state (from last quasi-quote run), run user code to
--   generate coercions
runusercoercion :: (RunUserCoercion -> Q [Dec]) -> (Name -> Q [Dec]) -> [Name] -> Q [Dec]
