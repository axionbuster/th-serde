<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Data.Serde.QQ</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">th-serde-0.1.3.0: A serialization/deserialization framework for Haskell</span><ul class="links" id="page-menu"><li><a href="src/Data.Serde.QQ.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>GHC2021</td></tr></table><p class="caption">Data.Serde.QQ</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>The main stable interface for the th-serde library, providing QuasiQuoters
 for defining data types with separated serialization and validation logic.
 Other modules are considered internal and may change without notice.</p><h1>Overview</h1><p>This library helps separate your core data models from their serialization and
 validation logic. While newtypes are commonly used for this purpose, they become
 unwieldy with complex data types, especially when dealing with multiple fields
 that need validation or custom serialization.</p><h1>How It Works</h1><p>Given a data type definition with 'via' annotations, th-serde:</p><ol><li value="1">Generates your core data type with clean, simple fields</li><li value="2">Creates a &quot;shadow&quot; type with the validation/serialization wrappers</li><li value="3">Provides machinery to convert between them using <code><a href="../base-4.19.2.0/Data-Coerce.html#v:coerce" title="Data.Coerce">coerce</a></code></li></ol><p>Important: Shadow types are generated without any type class implementations.
 You must implement all needed type classes for shadow types using <code>runuserprep</code>.
 The QuasiQuoter never automatically derives any instances for shadow types.</p><h1>Example</h1><p>Here's a complete example:</p><pre>[serde|
.derive
  Eq Ord Show Read

-- Your core data type with validation annotations
-- Suppose Age, VerifyLength, and VerifyEmail are defined elsewhere
data Person
  age :: Int32 via Age                     -- Validate using Age newtype
  name :: String via VerifyLength 1 10     -- Must be 1-10 chars
  email :: String via VerifyEmail          -- Must be valid email
|]
</pre><p>This generates:</p><pre>-- Your clean business model
data Person = Person
  { age :: Int32    -- Clean types without validation wrappers
  , name :: String
  , email :: String
  } deriving (Eq, Ord, Show, Read)

-- Auto-generated shadow type for validation
data Person__ = Person__
  { age__ :: Age               -- Fields use validation wrappers
  , name__ :: VerifyLength 1 10
  , email__ :: VerifyEmail
  }
</pre><h1>Usage Pattern</h1><ol><li value="1">Define your types using the <code><a href="Data-Serde-QQ.html#v:serde" title="Data.Serde.QQ">serde</a></code> QuasiQuoter</li><li value="2">Call <code><a href="Data-Serde-QQ.html#v:runusercoercion" title="Data.Serde.QQ">runusercoercion</a></code> to implement validation/serialization</li></ol><h1>Syntax Reference</h1><h2>Deriving Classes</h2><p>Use <code>.derive</code> at the start to specify which classes to derive:</p><pre>.derive
  Eq Ord Show Read  -- These will be derived for all types except shadow types
</pre><h2>Data Types</h2><pre>data Person                    -- Regular data type
  field :: Type via Validator  -- Field with validation
  plain :: Type                -- Field without validation
</pre><h2>Newtypes</h2><p>Unlike data types, newtypes using <code>via</code> (either in field or type position)
 will use GHC's <code>DerivingVia</code> mechanism directly instead of creating shadow types.
 This requires the <code>DerivingVia</code> language extension to be enabled.</p><pre>newtype Age        -- Simple newtype without via
  value :: Int32   -- Regular field, no shadow type created

newtype Number Double

newtype Validated Int32 via Check  -- With validation
-- ^ Generates:
--   newtype Validated = Validated Int32
--     deriving (...) via Check

newtype Name       -- With record syntax + via
  getName :: String via Verify
-- ^ Generates:
--   newtype Name = Name { getName :: String }
--     deriving (...) via Verify
</pre><h2>Type Aliases</h2><p>Type aliases do not participate in the derivation process and are not shadowed.</p><pre>type EmailStr String
</pre><h2>Examples</h2><p>Examples can be found in the test suite.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:serde">serde</a> :: <a href="../template-haskell-2.21.0.0/Language-Haskell-TH-Quote.html#t:QuasiQuoter" title="Language.Haskell.TH.Quote">QuasiQuoter</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:RunUserCoercion">RunUserCoercion</a> = <a href="#v:RunUserCoercion">RunUserCoercion</a> {<ul class="subs"><li><a href="#v:patnormal">patnormal</a> :: <a href="../template-haskell-2.21.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> <a href="../template-haskell-2.21.0.0/Language-Haskell-TH-Syntax.html#t:Pat" title="Language.Haskell.TH.Syntax">Pat</a></li><li><a href="#v:patshadow">patshadow</a> :: <a href="../template-haskell-2.21.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> <a href="../template-haskell-2.21.0.0/Language-Haskell-TH-Syntax.html#t:Pat" title="Language.Haskell.TH.Syntax">Pat</a></li><li><a href="#v:appnormal">appnormal</a> :: <a href="../template-haskell-2.21.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> <a href="../template-haskell-2.21.0.0/Language-Haskell-TH-Syntax.html#t:Exp" title="Language.Haskell.TH.Syntax">Exp</a></li><li><a href="#v:appshadow">appshadow</a> :: <a href="../template-haskell-2.21.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> <a href="../template-haskell-2.21.0.0/Language-Haskell-TH-Syntax.html#t:Exp" title="Language.Haskell.TH.Syntax">Exp</a></li><li><a href="#v:datatyp">datatyp</a> :: <a href="../template-haskell-2.21.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> <a href="../template-haskell-2.21.0.0/Language-Haskell-TH-Syntax.html#t:Type" title="Language.Haskell.TH.Syntax">Type</a></li><li><a href="#v:shadowdatatyp">shadowdatatyp</a> :: <a href="../template-haskell-2.21.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> <a href="../template-haskell-2.21.0.0/Language-Haskell-TH-Syntax.html#t:Type" title="Language.Haskell.TH.Syntax">Type</a></li></ul>}</li><li class="src short"><a href="#v:runusercoercion">runusercoercion</a> :: (<a href="Data-Serde-QQ.html#t:RunUserCoercion" title="Data.Serde.QQ">RunUserCoercion</a> -&gt; <a href="../template-haskell-2.21.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> [<a href="../template-haskell-2.21.0.0/Language-Haskell-TH-Syntax.html#t:Dec" title="Language.Haskell.TH.Syntax">Dec</a>]) -&gt; (<a href="../template-haskell-2.21.0.0/Language-Haskell-TH-Syntax.html#t:Name" title="Language.Haskell.TH.Syntax">Name</a> -&gt; <a href="../template-haskell-2.21.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> [<a href="../template-haskell-2.21.0.0/Language-Haskell-TH-Syntax.html#t:Dec" title="Language.Haskell.TH.Syntax">Dec</a>]) -&gt; [<a href="../template-haskell-2.21.0.0/Language-Haskell-TH-Syntax.html#t:Name" title="Language.Haskell.TH.Syntax">Name</a>] -&gt; <a href="../template-haskell-2.21.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> [<a href="../template-haskell-2.21.0.0/Language-Haskell-TH-Syntax.html#t:Dec" title="Language.Haskell.TH.Syntax">Dec</a>]</li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a id="v:serde" class="def">serde</a> :: <a href="../template-haskell-2.21.0.0/Language-Haskell-TH-Quote.html#t:QuasiQuoter" title="Language.Haskell.TH.Quote">QuasiQuoter</a> <a href="src/Data.Serde.QQ.html#serde" class="link">Source</a> <a href="#v:serde" class="selflink">#</a></p><div class="doc"><p>quasi-quoter for th-serde</p></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:RunUserCoercion" class="def">RunUserCoercion</a> <a href="src/Data.Serde.Internal.TH.html#RunUserCoercion" class="link">Source</a> <a href="#t:RunUserCoercion" class="selflink">#</a></p><div class="doc"><p>arguments to user code that generates coercions</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:RunUserCoercion" class="def">RunUserCoercion</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><ul><li><dfn class="src"><a id="v:patnormal" class="def">patnormal</a> :: <a href="../template-haskell-2.21.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> <a href="../template-haskell-2.21.0.0/Language-Haskell-TH-Syntax.html#t:Pat" title="Language.Haskell.TH.Syntax">Pat</a></dfn><div class="doc"><p>regular (non-record syntax) pattern for deconstruction (normal)</p></div></li><li><dfn class="src"><a id="v:patshadow" class="def">patshadow</a> :: <a href="../template-haskell-2.21.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> <a href="../template-haskell-2.21.0.0/Language-Haskell-TH-Syntax.html#t:Pat" title="Language.Haskell.TH.Syntax">Pat</a></dfn><div class="doc"><p>regular (non-record syntax) pattern for deconstruction (shadow)</p></div></li><li><dfn class="src"><a id="v:appnormal" class="def">appnormal</a> :: <a href="../template-haskell-2.21.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> <a href="../template-haskell-2.21.0.0/Language-Haskell-TH-Syntax.html#t:Exp" title="Language.Haskell.TH.Syntax">Exp</a></dfn><div class="doc"><p>apply shadow fields to a normal constructor</p></div></li><li><dfn class="src"><a id="v:appshadow" class="def">appshadow</a> :: <a href="../template-haskell-2.21.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> <a href="../template-haskell-2.21.0.0/Language-Haskell-TH-Syntax.html#t:Exp" title="Language.Haskell.TH.Syntax">Exp</a></dfn><div class="doc"><p>apply normal fields to a shadow constructor</p></div></li><li><dfn class="src"><a id="v:datatyp" class="def">datatyp</a> :: <a href="../template-haskell-2.21.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> <a href="../template-haskell-2.21.0.0/Language-Haskell-TH-Syntax.html#t:Type" title="Language.Haskell.TH.Syntax">Type</a></dfn><div class="doc"><p>class to derive</p></div></li><li><dfn class="src"><a id="v:shadowdatatyp" class="def">shadowdatatyp</a> :: <a href="../template-haskell-2.21.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> <a href="../template-haskell-2.21.0.0/Language-Haskell-TH-Syntax.html#t:Type" title="Language.Haskell.TH.Syntax">Type</a></dfn><div class="doc"><p>shadow data type</p></div></li></ul></div></td></tr></table></div></div><div class="top"><p class="src"><a id="v:runusercoercion" class="def">runusercoercion</a> <a href="src/Data.Serde.Internal.TH.html#runusercoercion" class="link">Source</a> <a href="#v:runusercoercion" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="Data-Serde-QQ.html#t:RunUserCoercion" title="Data.Serde.QQ">RunUserCoercion</a> -&gt; <a href="../template-haskell-2.21.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> [<a href="../template-haskell-2.21.0.0/Language-Haskell-TH-Syntax.html#t:Dec" title="Language.Haskell.TH.Syntax">Dec</a>])</td><td class="doc"><p>generate coercions between shadow and regular data types</p></td></tr><tr><td class="src">-&gt; (<a href="../template-haskell-2.21.0.0/Language-Haskell-TH-Syntax.html#t:Name" title="Language.Haskell.TH.Syntax">Name</a> -&gt; <a href="../template-haskell-2.21.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> [<a href="../template-haskell-2.21.0.0/Language-Haskell-TH-Syntax.html#t:Dec" title="Language.Haskell.TH.Syntax">Dec</a>])</td><td class="doc"><p>derive coercions for shadow data, regular data with no shadows,
 and newtypes</p></td></tr><tr><td class="src">-&gt; [<a href="../template-haskell-2.21.0.0/Language-Haskell-TH-Syntax.html#t:Name" title="Language.Haskell.TH.Syntax">Name</a>]</td><td class="doc"><p>preparations for shadow types</p></td></tr><tr><td class="src">-&gt; <a href="../template-haskell-2.21.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> [<a href="../template-haskell-2.21.0.0/Language-Haskell-TH-Syntax.html#t:Dec" title="Language.Haskell.TH.Syntax">Dec</a>]</td><td class="doc"><p>generated coercions</p></td></tr></table></div><div class="doc"><p>using the stored state (from last quasi-quote run), run user code
 to generate coercions</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.30.0</p></div></body></html>