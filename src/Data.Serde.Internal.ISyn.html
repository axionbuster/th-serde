<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# OPTIONS_GHC -Wno-partial-fields #-}</span><span>
</span><span id="line-2"></span><span>
</span><span id="line-3"></span><span class="hs-comment">-- | intermediate syntax for the parser</span><span>
</span><span id="line-4"></span><span class="hs-comment">--</span><span>
</span><span id="line-5"></span><span class="hs-comment">-- see &quot;Data.Serde.Syn&quot; for the grammar</span><span>
</span><span id="line-6"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Data.Serde.Internal.ISyn</span><span>
</span><span id="line-7"></span><span>  </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="Data.Serde.Internal.ISyn.html#parsetop"><span class="hs-identifier">parsetop</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-8"></span><span>    </span><span class="annot"><a href="Data.Serde.Internal.ISyn.html#ISyn"><span class="hs-identifier">ISyn</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-9"></span><span>    </span><span class="annot"><a href="Data.Serde.Internal.ISyn.html#ISynFld"><span class="hs-identifier">ISynFld</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-10"></span><span>    </span><span class="annot"><a href="Data.Serde.Internal.ISyn.html#INewtypePayload"><span class="hs-identifier">INewtypePayload</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-11"></span><span>    </span><span class="annot"><a href="Data.Serde.Internal.ISyn.html#ViaInfo"><span class="hs-identifier">ViaInfo</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-12"></span><span>    </span><span class="annot"><a href="Data.Serde.Internal.ISyn.html#Derive"><span class="hs-identifier">Derive</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-13"></span><span>    </span><span class="annot"><a href="Data.Serde.Internal.ISyn.html#Parser"><span class="hs-identifier">Parser</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-14"></span><span>
</span><span id="line-15"></span><span>    </span><span class="annot"><span class="hs-comment">-- * debug</span></span><span>
</span><span id="line-16"></span><span>    </span><span class="annot"><a href="Data.Serde.Internal.ISyn.html#_testbody1"><span class="hs-identifier">_testbody1</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-17"></span><span>  </span><span class="hs-special">)</span><span>
</span><span id="line-18"></span><span class="hs-keyword">where</span><span>
</span><span id="line-19"></span><span>
</span><span id="line-20"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Monad</span></span><span>
</span><span id="line-21"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Void</span></span><span>
</span><span id="line-22"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Text.Megaparsec</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Parsec</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">many</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-operator">(&lt;|&gt;)</span></span><span class="hs-special">)</span><span>
</span><span id="line-23"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Text.Megaparsec</span></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">M</span></span><span>
</span><span id="line-24"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Text.Megaparsec.Char</span></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">M</span></span><span>
</span><span id="line-25"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Text.Megaparsec.Char.Lexer</span></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">L</span></span><span>
</span><span id="line-26"></span><span>
</span><span id="line-27"></span><span class="annot"><span class="hs-comment">-- | parser type for the intermediate syntax</span></span><span>
</span><span id="line-28"></span><span class="hs-keyword">type</span><span> </span><span id="Parser"><span class="annot"><a href="Data.Serde.Internal.ISyn.html#Parser"><span class="hs-identifier hs-var">Parser</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Parsec</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Void</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>
</span><span id="line-29"></span><span>
</span><span id="line-30"></span><span class="hs-comment">-- intermediate syntax types</span><span>
</span><span id="line-31"></span><span>
</span><span id="line-32"></span><span class="hs-comment">-- | intermediate representation of type definitions</span><span>
</span><span id="line-33"></span><span class="hs-comment">-- parsed from the input syntax. can be a data type,</span><span>
</span><span id="line-34"></span><span class="hs-comment">-- newtype, or type alias.</span><span>
</span><span id="line-35"></span><span class="hs-keyword">data</span><span> </span><span id="ISyn"><span class="annot"><a href="Data.Serde.Internal.ISyn.html#ISyn"><span class="hs-identifier hs-var">ISyn</span></a></span></span><span>
</span><span id="line-36"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="ISynData"><span class="annot"><a href="Data.Serde.Internal.ISyn.html#ISynData"><span class="hs-identifier hs-var">ISynData</span></a></span></span><span> </span><span class="hs-special">{</span><span id="isnam"><span class="annot"><span class="annottext">ISyn -&gt; [Char]
</span><a href="Data.Serde.Internal.ISyn.html#isnam"><span class="hs-identifier hs-var hs-var">isnam</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">,</span><span> </span><span id="isflds"><span class="annot"><span class="annottext">ISyn -&gt; [ISynFld]
</span><a href="Data.Serde.Internal.ISyn.html#isflds"><span class="hs-identifier hs-var hs-var">isflds</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Data.Serde.Internal.ISyn.html#ISynFld"><span class="hs-identifier hs-type">ISynFld</span></a></span><span class="hs-special">]</span><span class="hs-special">}</span><span>
</span><span id="line-37"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ISynNewtype"><span class="annot"><a href="Data.Serde.Internal.ISyn.html#ISynNewtype"><span class="hs-identifier hs-var">ISynNewtype</span></a></span></span><span> </span><span class="hs-special">{</span><span id="isnam"><span class="annot"><a href="Data.Serde.Internal.ISyn.html#isnam"><span class="hs-identifier hs-var">isnam</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">,</span><span> </span><span id="isfld1"><span class="annot"><span class="annottext">ISyn -&gt; INewtypePayload
</span><a href="Data.Serde.Internal.ISyn.html#isfld1"><span class="hs-identifier hs-var hs-var">isfld1</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.Serde.Internal.ISyn.html#INewtypePayload"><span class="hs-identifier hs-type">INewtypePayload</span></a></span><span class="hs-special">}</span><span>
</span><span id="line-38"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ISynAlias"><span class="annot"><a href="Data.Serde.Internal.ISyn.html#ISynAlias"><span class="hs-identifier hs-var">ISynAlias</span></a></span></span><span> </span><span class="hs-special">{</span><span id="isnam"><span class="annot"><a href="Data.Serde.Internal.ISyn.html#isnam"><span class="hs-identifier hs-var">isnam</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">,</span><span> </span><span id="isdest"><span class="annot"><span class="annottext">ISyn -&gt; [Char]
</span><a href="Data.Serde.Internal.ISyn.html#isdest"><span class="hs-identifier hs-var hs-var">isdest</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">}</span><span>
</span><span id="line-39"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679116126"><span id="local-6989586621679116142"><span id="local-6989586621679116146"><span class="annot"><span class="annottext">Int -&gt; ISyn -&gt; ShowS
[ISyn] -&gt; ShowS
ISyn -&gt; [Char]
(Int -&gt; ISyn -&gt; ShowS)
-&gt; (ISyn -&gt; [Char]) -&gt; ([ISyn] -&gt; ShowS) -&gt; Show ISyn
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; [Char]) -&gt; ([a] -&gt; ShowS) -&gt; Show a
$cshowsPrec :: Int -&gt; ISyn -&gt; ShowS
showsPrec :: Int -&gt; ISyn -&gt; ShowS
$cshow :: ISyn -&gt; [Char]
show :: ISyn -&gt; [Char]
$cshowList :: [ISyn] -&gt; ShowS
showList :: [ISyn] -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-40"></span><span>
</span><span id="line-41"></span><span class="hs-comment">-- | payload for newtype definitions, which can either be</span><span>
</span><span id="line-42"></span><span class="hs-comment">-- a field with a name and type, or just a type</span><span>
</span><span id="line-43"></span><span class="hs-keyword">data</span><span> </span><span id="INewtypePayload"><span class="annot"><a href="Data.Serde.Internal.ISyn.html#INewtypePayload"><span class="hs-identifier hs-var">INewtypePayload</span></a></span></span><span>
</span><span id="line-44"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="IField"><span class="annot"><a href="Data.Serde.Internal.ISyn.html#IField"><span class="hs-identifier hs-var">IField</span></a></span></span><span> </span><span class="annot"><a href="Data.Serde.Internal.ISyn.html#ISynFld"><span class="hs-identifier hs-type">ISynFld</span></a></span><span>
</span><span id="line-45"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="IType"><span class="annot"><a href="Data.Serde.Internal.ISyn.html#IType"><span class="hs-identifier hs-var">IType</span></a></span></span><span> </span><span class="annot"><a href="Data.Serde.Internal.ISyn.html#ViaInfo"><span class="hs-identifier hs-type">ViaInfo</span></a></span><span>
</span><span id="line-46"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679116154"><span id="local-6989586621679116161"><span id="local-6989586621679116164"><span class="annot"><span class="annottext">Int -&gt; INewtypePayload -&gt; ShowS
[INewtypePayload] -&gt; ShowS
INewtypePayload -&gt; [Char]
(Int -&gt; INewtypePayload -&gt; ShowS)
-&gt; (INewtypePayload -&gt; [Char])
-&gt; ([INewtypePayload] -&gt; ShowS)
-&gt; Show INewtypePayload
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; [Char]) -&gt; ([a] -&gt; ShowS) -&gt; Show a
$cshowsPrec :: Int -&gt; INewtypePayload -&gt; ShowS
showsPrec :: Int -&gt; INewtypePayload -&gt; ShowS
$cshow :: INewtypePayload -&gt; [Char]
show :: INewtypePayload -&gt; [Char]
$cshowList :: [INewtypePayload] -&gt; ShowS
showList :: [INewtypePayload] -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-47"></span><span>
</span><span id="line-48"></span><span class="hs-comment">-- | field definition for data types and newtypes,</span><span>
</span><span id="line-49"></span><span class="hs-comment">-- containing a field name and its type information</span><span>
</span><span id="line-50"></span><span class="hs-keyword">data</span><span> </span><span id="ISynFld"><span class="annot"><a href="Data.Serde.Internal.ISyn.html#ISynFld"><span class="hs-identifier hs-var">ISynFld</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="ISynFld"><span class="annot"><a href="Data.Serde.Internal.ISyn.html#ISynFld"><span class="hs-identifier hs-var">ISynFld</span></a></span></span><span>
</span><span id="line-51"></span><span>  </span><span class="hs-special">{</span><span> </span><span id="isfldnam"><span class="annot"><span class="annottext">ISynFld -&gt; [Char]
</span><a href="Data.Serde.Internal.ISyn.html#isfldnam"><span class="hs-identifier hs-var hs-var">isfldnam</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">,</span><span>
</span><span id="line-52"></span><span>    </span><span id="isfldtyp"><span class="annot"><span class="annottext">ISynFld -&gt; ViaInfo
</span><a href="Data.Serde.Internal.ISyn.html#isfldtyp"><span class="hs-identifier hs-var hs-var">isfldtyp</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.Serde.Internal.ISyn.html#ViaInfo"><span class="hs-identifier hs-type">ViaInfo</span></a></span><span>
</span><span id="line-53"></span><span>  </span><span class="hs-special">}</span><span>
</span><span id="line-54"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679116170"><span id="local-6989586621679116176"><span id="local-6989586621679116179"><span class="annot"><span class="annottext">Int -&gt; ISynFld -&gt; ShowS
[ISynFld] -&gt; ShowS
ISynFld -&gt; [Char]
(Int -&gt; ISynFld -&gt; ShowS)
-&gt; (ISynFld -&gt; [Char]) -&gt; ([ISynFld] -&gt; ShowS) -&gt; Show ISynFld
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; [Char]) -&gt; ([a] -&gt; ShowS) -&gt; Show a
$cshowsPrec :: Int -&gt; ISynFld -&gt; ShowS
showsPrec :: Int -&gt; ISynFld -&gt; ShowS
$cshow :: ISynFld -&gt; [Char]
show :: ISynFld -&gt; [Char]
$cshowList :: [ISynFld] -&gt; ShowS
showList :: [ISynFld] -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-55"></span><span>
</span><span id="line-56"></span><span class="annot"><span class="hs-comment">-- | collection of type classes to derive for all defined types</span></span><span>
</span><span id="line-57"></span><span class="hs-keyword">newtype</span><span> </span><span id="Derive"><span class="annot"><a href="Data.Serde.Internal.ISyn.html#Derive"><span class="hs-identifier hs-var">Derive</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="Derive"><span class="annot"><a href="Data.Serde.Internal.ISyn.html#Derive"><span class="hs-identifier hs-var">Derive</span></a></span></span><span>
</span><span id="line-58"></span><span>  </span><span class="hs-special">{</span><span> </span><span id="getderive"><span class="annot"><span class="annottext">Derive -&gt; [[Char]]
</span><a href="Data.Serde.Internal.ISyn.html#getderive"><span class="hs-identifier hs-var hs-var">getderive</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">]</span><span>
</span><span id="line-59"></span><span>  </span><span class="hs-special">}</span><span>
</span><span id="line-60"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679116184"><span id="local-6989586621679116189"><span id="local-6989586621679116193"><span class="annot"><span class="annottext">Int -&gt; Derive -&gt; ShowS
[Derive] -&gt; ShowS
Derive -&gt; [Char]
(Int -&gt; Derive -&gt; ShowS)
-&gt; (Derive -&gt; [Char]) -&gt; ([Derive] -&gt; ShowS) -&gt; Show Derive
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; [Char]) -&gt; ([a] -&gt; ShowS) -&gt; Show a
$cshowsPrec :: Int -&gt; Derive -&gt; ShowS
showsPrec :: Int -&gt; Derive -&gt; ShowS
$cshow :: Derive -&gt; [Char]
show :: Derive -&gt; [Char]
$cshowList :: [Derive] -&gt; ShowS
showList :: [Derive] -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-61"></span><span>
</span><span id="line-62"></span><span class="annot"><span class="hs-comment">-- | type information that may include a 'via' clause</span></span><span>
</span><span id="line-63"></span><span class="hs-keyword">data</span><span> </span><span id="ViaInfo"><span class="annot"><a href="Data.Serde.Internal.ISyn.html#ViaInfo"><span class="hs-identifier hs-var">ViaInfo</span></a></span></span><span>
</span><span id="line-64"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="Plain"><span class="annot"><a href="Data.Serde.Internal.ISyn.html#Plain"><span class="hs-identifier hs-var">Plain</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>
</span><span id="line-65"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="WithVia"><span class="annot"><a href="Data.Serde.Internal.ISyn.html#WithVia"><span class="hs-identifier hs-var">WithVia</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>
</span><span id="line-66"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679116199"><span id="local-6989586621679116207"><span id="local-6989586621679116210"><span class="annot"><span class="annottext">Int -&gt; ViaInfo -&gt; ShowS
[ViaInfo] -&gt; ShowS
ViaInfo -&gt; [Char]
(Int -&gt; ViaInfo -&gt; ShowS)
-&gt; (ViaInfo -&gt; [Char]) -&gt; ([ViaInfo] -&gt; ShowS) -&gt; Show ViaInfo
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; [Char]) -&gt; ([a] -&gt; ShowS) -&gt; Show a
$cshowsPrec :: Int -&gt; ViaInfo -&gt; ShowS
showsPrec :: Int -&gt; ViaInfo -&gt; ShowS
$cshow :: ViaInfo -&gt; [Char]
show :: ViaInfo -&gt; [Char]
$cshowList :: [ViaInfo] -&gt; ShowS
showList :: [ViaInfo] -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-67"></span><span>
</span><span id="line-68"></span><span class="hs-comment">-- parser utilities</span><span>
</span><span id="line-69"></span><span class="annot"><a href="Data.Serde.Internal.ISyn.html#sc"><span class="hs-identifier hs-type">sc</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.Serde.Internal.ISyn.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-70"></span><span id="sc"><span class="annot"><span class="annottext">sc :: Parser ()
</span><a href="Data.Serde.Internal.ISyn.html#sc"><span class="hs-identifier hs-var hs-var">sc</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parser () -&gt; Parser () -&gt; Parser () -&gt; Parser ()
forall e s (m :: * -&gt; *).
MonadParsec e s m =&gt;
m () -&gt; m () -&gt; m () -&gt; m ()
</span><span class="hs-identifier hs-var">L.space</span></span><span> </span><span class="annot"><span class="annottext">Parser ()
forall e s (m :: * -&gt; *).
(MonadParsec e s m, Token s ~ Char) =&gt;
m ()
</span><span class="hs-identifier hs-var">M.space1</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Tokens [Char] -&gt; Parser ()
forall e s (m :: * -&gt; *).
(MonadParsec e s m, Token s ~ Char) =&gt;
Tokens s -&gt; m ()
</span><span class="hs-identifier hs-var">L.skipLineComment</span></span><span> </span><span class="annot"><span class="annottext">[Char]
Tokens [Char]
</span><span class="hs-string">&quot;--&quot;</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Tokens [Char] -&gt; Tokens [Char] -&gt; Parser ()
forall e s (m :: * -&gt; *).
MonadParsec e s m =&gt;
Tokens s -&gt; Tokens s -&gt; m ()
</span><span class="hs-identifier hs-var">L.skipBlockComment</span></span><span> </span><span class="annot"><span class="annottext">[Char]
Tokens [Char]
</span><span class="hs-string">&quot;{-&quot;</span></span><span> </span><span class="annot"><span class="annottext">[Char]
Tokens [Char]
</span><span class="hs-string">&quot;-}&quot;</span></span><span class="hs-special">)</span><span>
</span><span id="line-71"></span><span>
</span><span id="line-72"></span><span class="annot"><a href="Data.Serde.Internal.ISyn.html#scnonl"><span class="hs-identifier hs-type">scnonl</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.Serde.Internal.ISyn.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-73"></span><span id="scnonl"><span class="annot"><span class="annottext">scnonl :: Parser ()
</span><a href="Data.Serde.Internal.ISyn.html#scnonl"><span class="hs-identifier hs-var hs-var">scnonl</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-74"></span><span>  </span><span class="annot"><span class="annottext">Parser () -&gt; Parser () -&gt; Parser () -&gt; Parser ()
forall e s (m :: * -&gt; *).
MonadParsec e s m =&gt;
m () -&gt; m () -&gt; m () -&gt; m ()
</span><span class="hs-identifier hs-var">L.space</span></span><span> </span><span class="annot"><span class="annottext">Parser ()
forall e s (m :: * -&gt; *).
(MonadParsec e s m, Token s ~ Char) =&gt;
m ()
</span><span class="hs-identifier hs-var">M.hspace1</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Tokens [Char] -&gt; Parser ()
forall e s (m :: * -&gt; *).
(MonadParsec e s m, Token s ~ Char) =&gt;
Tokens s -&gt; m ()
</span><span class="hs-identifier hs-var">L.skipLineComment</span></span><span> </span><span class="annot"><span class="annottext">[Char]
Tokens [Char]
</span><span class="hs-string">&quot;--&quot;</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Tokens [Char] -&gt; Tokens [Char] -&gt; Parser ()
forall e s (m :: * -&gt; *).
MonadParsec e s m =&gt;
Tokens s -&gt; Tokens s -&gt; m ()
</span><span class="hs-identifier hs-var">L.skipBlockComment</span></span><span> </span><span class="annot"><span class="annottext">[Char]
Tokens [Char]
</span><span class="hs-string">&quot;{-&quot;</span></span><span> </span><span class="annot"><span class="annottext">[Char]
Tokens [Char]
</span><span class="hs-string">&quot;-}&quot;</span></span><span class="hs-special">)</span><span>
</span><span id="line-75"></span><span>
</span><span id="line-76"></span><span id="local-6989586621679115922"><span class="annot"><a href="Data.Serde.Internal.ISyn.html#lexeme"><span class="hs-identifier hs-type">lexeme</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.Serde.Internal.ISyn.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679115922"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Serde.Internal.ISyn.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679115922"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-77"></span><span id="lexeme"><span class="annot"><span class="annottext">lexeme :: forall a. Parser a -&gt; Parser a
</span><a href="Data.Serde.Internal.ISyn.html#lexeme"><span class="hs-identifier hs-var hs-var">lexeme</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parser ()
-&gt; ParsecT Void [Char] Identity a -&gt; ParsecT Void [Char] Identity a
forall e s (m :: * -&gt; *) a. MonadParsec e s m =&gt; m () -&gt; m a -&gt; m a
</span><span class="hs-identifier hs-var">L.lexeme</span></span><span> </span><span class="annot"><span class="annottext">Parser ()
</span><a href="Data.Serde.Internal.ISyn.html#scnonl"><span class="hs-identifier hs-var">scnonl</span></a></span><span>
</span><span id="line-78"></span><span>
</span><span id="line-79"></span><span class="annot"><a href="Data.Serde.Internal.ISyn.html#identifier"><span class="hs-identifier hs-type">identifier</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.Serde.Internal.ISyn.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>
</span><span id="line-80"></span><span id="identifier"><span class="annot"><span class="annottext">identifier :: Parser [Char]
</span><a href="Data.Serde.Internal.ISyn.html#identifier"><span class="hs-identifier hs-var hs-var">identifier</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-glyph">:</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Char -&gt; ShowS)
-&gt; ParsecT Void [Char] Identity Char
-&gt; ParsecT Void [Char] Identity ShowS
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT Void [Char] Identity Char
</span><a href="#local-6989586621679116224"><span class="hs-identifier hs-var">headchar</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT Void [Char] Identity ShowS
-&gt; Parser [Char] -&gt; Parser [Char]
forall a b.
ParsecT Void [Char] Identity (a -&gt; b)
-&gt; ParsecT Void [Char] Identity a -&gt; ParsecT Void [Char] Identity b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT Void [Char] Identity Char -&gt; Parser [Char]
forall (m :: * -&gt; *) a. MonadPlus m =&gt; m a -&gt; m [a]
</span><span class="hs-identifier hs-var">M.many</span></span><span> </span><span class="annot"><span class="annottext">ParsecT Void [Char] Identity Char
</span><a href="#local-6989586621679116225"><span class="hs-identifier hs-var">bodychar</span></a></span><span>
</span><span id="line-81"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-82"></span><span>    </span><span id="local-6989586621679116224"><span class="annot"><span class="annottext">headchar :: ParsecT Void [Char] Identity Char
</span><a href="#local-6989586621679116224"><span class="hs-identifier hs-var hs-var">headchar</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ParsecT Void [Char] Identity Char
ParsecT Void [Char] Identity (Token [Char])
forall e s (m :: * -&gt; *).
(MonadParsec e s m, Token s ~ Char) =&gt;
m (Token s)
</span><span class="hs-identifier hs-var">M.letterChar</span></span><span> </span><span class="annot"><span class="annottext">ParsecT Void [Char] Identity Char
-&gt; ParsecT Void [Char] Identity Char
-&gt; ParsecT Void [Char] Identity Char
forall a.
ParsecT Void [Char] Identity a
-&gt; ParsecT Void [Char] Identity a -&gt; ParsecT Void [Char] Identity a
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f a -&gt; f a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">Token [Char] -&gt; ParsecT Void [Char] Identity (Token [Char])
forall e s (m :: * -&gt; *).
(MonadParsec e s m, Token s ~ Char) =&gt;
Token s -&gt; m (Token s)
</span><span class="hs-identifier hs-var">M.char</span></span><span> </span><span class="annot"><span class="annottext">Char
Token [Char]
</span><span class="hs-char">'_'</span></span><span>
</span><span id="line-83"></span><span>    </span><span id="local-6989586621679116225"><span class="annot"><span class="annottext">bodychar :: ParsecT Void [Char] Identity Char
</span><a href="#local-6989586621679116225"><span class="hs-identifier hs-var hs-var">bodychar</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ParsecT Void [Char] Identity Char
ParsecT Void [Char] Identity (Token [Char])
forall e s (m :: * -&gt; *).
(MonadParsec e s m, Token s ~ Char) =&gt;
m (Token s)
</span><span class="hs-identifier hs-var">M.alphaNumChar</span></span><span> </span><span class="annot"><span class="annottext">ParsecT Void [Char] Identity Char
-&gt; ParsecT Void [Char] Identity Char
-&gt; ParsecT Void [Char] Identity Char
forall a.
ParsecT Void [Char] Identity a
-&gt; ParsecT Void [Char] Identity a -&gt; ParsecT Void [Char] Identity a
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f a -&gt; f a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">Token [Char] -&gt; ParsecT Void [Char] Identity (Token [Char])
forall e s (m :: * -&gt; *).
(MonadParsec e s m, Token s ~ Char) =&gt;
Token s -&gt; m (Token s)
</span><span class="hs-identifier hs-var">M.char</span></span><span> </span><span class="annot"><span class="annottext">Char
Token [Char]
</span><span class="hs-char">'_'</span></span><span> </span><span class="annot"><span class="annottext">ParsecT Void [Char] Identity Char
-&gt; ParsecT Void [Char] Identity Char
-&gt; ParsecT Void [Char] Identity Char
forall a.
ParsecT Void [Char] Identity a
-&gt; ParsecT Void [Char] Identity a -&gt; ParsecT Void [Char] Identity a
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f a -&gt; f a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">Token [Char] -&gt; ParsecT Void [Char] Identity (Token [Char])
forall e s (m :: * -&gt; *).
(MonadParsec e s m, Token s ~ Char) =&gt;
Token s -&gt; m (Token s)
</span><span class="hs-identifier hs-var">M.char</span></span><span> </span><span class="annot"><span class="annottext">Char
Token [Char]
</span><span class="hs-char">'\''</span></span><span>
</span><span id="line-84"></span><span>
</span><span id="line-85"></span><span class="annot"><a href="Data.Serde.Internal.ISyn.html#typechars"><span class="hs-identifier hs-type">typechars</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.Serde.Internal.ISyn.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Char</span></span><span>
</span><span id="line-86"></span><span id="typechars"><span class="annot"><span class="annottext">typechars :: ParsecT Void [Char] Identity Char
</span><a href="Data.Serde.Internal.ISyn.html#typechars"><span class="hs-identifier hs-var hs-var">typechars</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ParsecT Void [Char] Identity Char
ParsecT Void [Char] Identity (Token [Char])
forall e s (m :: * -&gt; *).
(MonadParsec e s m, Token s ~ Char) =&gt;
m (Token s)
</span><span class="hs-identifier hs-var">M.alphaNumChar</span></span><span> </span><span class="annot"><span class="annottext">ParsecT Void [Char] Identity Char
-&gt; ParsecT Void [Char] Identity Char
-&gt; ParsecT Void [Char] Identity Char
forall a.
ParsecT Void [Char] Identity a
-&gt; ParsecT Void [Char] Identity a -&gt; ParsecT Void [Char] Identity a
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f a -&gt; f a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">[Token [Char]] -&gt; ParsecT Void [Char] Identity (Token [Char])
forall (f :: * -&gt; *) e s (m :: * -&gt; *).
(Foldable f, MonadParsec e s m) =&gt;
f (Token s) -&gt; m (Token s)
</span><span class="hs-identifier hs-var">M.oneOf</span></span><span> </span><span class="annot"><span class="annottext">[Char]
[Token [Char]]
</span><span class="hs-string">&quot;_'() ,:[]=.&lt;&gt;-|\&quot;&quot;</span></span><span>
</span><span id="line-87"></span><span>
</span><span id="line-88"></span><span class="annot"><a href="Data.Serde.Internal.ISyn.html#untileol"><span class="hs-identifier hs-type">untileol</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.Serde.Internal.ISyn.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Char</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Serde.Internal.ISyn.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>
</span><span id="line-89"></span><span id="untileol"><span class="annot"><span class="annottext">untileol :: ParsecT Void [Char] Identity Char -&gt; Parser [Char]
</span><a href="Data.Serde.Internal.ISyn.html#untileol"><span class="hs-identifier hs-var hs-var">untileol</span></a></span></span><span> </span><span id="local-6989586621679116283"><span class="annot"><span class="annottext">ParsecT Void [Char] Identity Char
</span><a href="#local-6989586621679116283"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parser [Char] -&gt; Parser [Char]
forall a. Parser a -&gt; Parser a
forall e s (m :: * -&gt; *) a. MonadParsec e s m =&gt; m a -&gt; m a
</span><span class="hs-identifier hs-var">M.try</span></span><span> </span><span class="annot"><span class="annottext">(Parser [Char] -&gt; Parser [Char]) -&gt; Parser [Char] -&gt; Parser [Char]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">ParsecT Void [Char] Identity Char -&gt; Parser () -&gt; Parser [Char]
forall (m :: * -&gt; *) a end. MonadPlus m =&gt; m a -&gt; m end -&gt; m [a]
</span><span class="hs-identifier hs-var">M.manyTill</span></span><span> </span><span class="annot"><span class="annottext">ParsecT Void [Char] Identity Char
</span><a href="#local-6989586621679116283"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parser () -&gt; Parser ()
forall a. Parser a -&gt; Parser a
forall e s (m :: * -&gt; *) a. MonadParsec e s m =&gt; m a -&gt; m a
</span><span class="hs-identifier hs-var">M.lookAhead</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parser ()
forall e s (m :: * -&gt; *). MonadParsec e s m =&gt; m ()
</span><span class="hs-identifier hs-var">M.eof</span></span><span> </span><span class="annot"><span class="annottext">Parser () -&gt; Parser () -&gt; Parser ()
forall a.
ParsecT Void [Char] Identity a
-&gt; ParsecT Void [Char] Identity a -&gt; ParsecT Void [Char] Identity a
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f a -&gt; f a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT Void [Char] Identity (Tokens [Char]) -&gt; Parser ()
forall (f :: * -&gt; *) a. Functor f =&gt; f a -&gt; f ()
</span><span class="hs-identifier hs-var">void</span></span><span> </span><span class="annot"><span class="annottext">ParsecT Void [Char] Identity (Tokens [Char])
forall e s (m :: * -&gt; *).
(MonadParsec e s m, Token s ~ Char) =&gt;
m (Tokens s)
</span><span class="hs-identifier hs-var">M.eol</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-90"></span><span>
</span><span id="line-91"></span><span class="annot"><a href="Data.Serde.Internal.ISyn.html#untilvia"><span class="hs-identifier hs-type">untilvia</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.Serde.Internal.ISyn.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>
</span><span id="line-92"></span><span id="untilvia"><span class="annot"><span class="annottext">untilvia :: Parser [Char]
</span><a href="Data.Serde.Internal.ISyn.html#untilvia"><span class="hs-identifier hs-var hs-var">untilvia</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-93"></span><span>  </span><span class="annot"><span class="annottext">Parser [Char] -&gt; Parser [Char]
forall a. Parser a -&gt; Parser a
forall e s (m :: * -&gt; *) a. MonadParsec e s m =&gt; m a -&gt; m a
</span><span class="hs-identifier hs-var">M.try</span></span><span> </span><span class="annot"><span class="annottext">(Parser [Char] -&gt; Parser [Char]) -&gt; Parser [Char] -&gt; Parser [Char]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-94"></span><span>    </span><span class="annot"><span class="annottext">ShowS -&gt; Parser [Char] -&gt; Parser [Char]
forall a b.
(a -&gt; b)
-&gt; ParsecT Void [Char] Identity a -&gt; ParsecT Void [Char] Identity b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ShowS
forall a. [a] -&gt; [a]
</span><span class="hs-identifier hs-var">reverse</span></span><span> </span><span class="annot"><span class="annottext">ShowS -&gt; ShowS -&gt; ShowS
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(Char -&gt; Bool) -&gt; ShowS
forall a. (a -&gt; Bool) -&gt; [a] -&gt; [a]
</span><span class="hs-identifier hs-var">dropWhile</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Char -&gt; Char -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Char
</span><span class="hs-char">' '</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">ShowS -&gt; ShowS -&gt; ShowS
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">ShowS
forall a. [a] -&gt; [a]
</span><span class="hs-identifier hs-var">reverse</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Parser [Char] -&gt; Parser [Char]) -&gt; Parser [Char] -&gt; Parser [Char]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-95"></span><span>      </span><span class="annot"><span class="annottext">ParsecT Void [Char] Identity Char -&gt; Parser () -&gt; Parser [Char]
forall (m :: * -&gt; *) a end. MonadPlus m =&gt; m a -&gt; m end -&gt; m [a]
</span><span class="hs-identifier hs-var">M.manyTill</span></span><span> </span><span class="annot"><span class="annottext">ParsecT Void [Char] Identity Char
</span><a href="Data.Serde.Internal.ISyn.html#typechars"><span class="hs-identifier hs-var">typechars</span></a></span><span> </span><span class="annot"><span class="annottext">(Parser () -&gt; Parser [Char]) -&gt; Parser () -&gt; Parser [Char]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-96"></span><span>        </span><span class="annot"><span class="annottext">Parser () -&gt; Parser ()
forall a. Parser a -&gt; Parser a
forall e s (m :: * -&gt; *) a. MonadParsec e s m =&gt; m a -&gt; m a
</span><span class="hs-identifier hs-var">M.lookAhead</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ParsecT Void [Char] Identity (Tokens [Char]) -&gt; Parser ()
forall (f :: * -&gt; *) a. Functor f =&gt; f a -&gt; f ()
</span><span class="hs-identifier hs-var">void</span></span><span> </span><span class="annot"><span class="annottext">ParsecT Void [Char] Identity (Tokens [Char])
forall e s (m :: * -&gt; *).
(MonadParsec e s m, Token s ~ Char) =&gt;
m (Tokens s)
</span><span class="hs-identifier hs-var">M.eol</span></span><span> </span><span class="annot"><span class="annottext">Parser () -&gt; Parser () -&gt; Parser ()
forall a.
ParsecT Void [Char] Identity a
-&gt; ParsecT Void [Char] Identity a -&gt; ParsecT Void [Char] Identity a
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f a -&gt; f a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT Void [Char] Identity (Tokens [Char]) -&gt; Parser ()
forall (f :: * -&gt; *) a. Functor f =&gt; f a -&gt; f ()
</span><span class="hs-identifier hs-var">void</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Tokens [Char] -&gt; ParsecT Void [Char] Identity (Tokens [Char])
forall e s (m :: * -&gt; *).
MonadParsec e s m =&gt;
Tokens s -&gt; m (Tokens s)
</span><span class="hs-identifier hs-var">M.string</span></span><span> </span><span class="annot"><span class="annottext">[Char]
Tokens [Char]
</span><span class="hs-string">&quot;via&quot;</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Parser () -&gt; Parser () -&gt; Parser ()
forall a.
ParsecT Void [Char] Identity a
-&gt; ParsecT Void [Char] Identity a -&gt; ParsecT Void [Char] Identity a
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f a -&gt; f a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser ()
forall e s (m :: * -&gt; *). MonadParsec e s m =&gt; m ()
</span><span class="hs-identifier hs-var">M.eof</span></span><span class="hs-special">)</span><span>
</span><span id="line-97"></span><span>
</span><span id="line-98"></span><span class="hs-comment">-- Main parsers</span><span>
</span><span id="line-99"></span><span class="annot"><a href="Data.Serde.Internal.ISyn.html#parsetype"><span class="hs-identifier hs-type">parsetype</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.Serde.Internal.ISyn.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Data.Serde.Internal.ISyn.html#ViaInfo"><span class="hs-identifier hs-type">ViaInfo</span></a></span><span>
</span><span id="line-100"></span><span id="parsetype"><span class="annot"><span class="annottext">parsetype :: Parser ViaInfo
</span><a href="Data.Serde.Internal.ISyn.html#parsetype"><span class="hs-identifier hs-var hs-var">parsetype</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-101"></span><span>  </span><span class="annot"><span class="annottext">[Parser ViaInfo] -&gt; Parser ViaInfo
forall (f :: * -&gt; *) (m :: * -&gt; *) a.
(Foldable f, Alternative m) =&gt;
f (m a) -&gt; m a
</span><span class="hs-identifier hs-var">M.choice</span></span><span>
</span><span id="line-102"></span><span>    </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">Parser ViaInfo -&gt; Parser ViaInfo
forall a. Parser a -&gt; Parser a
forall e s (m :: * -&gt; *) a. MonadParsec e s m =&gt; m a -&gt; m a
</span><span class="hs-identifier hs-var">M.try</span></span><span> </span><span class="annot"><span class="annottext">(Parser ViaInfo -&gt; Parser ViaInfo)
-&gt; Parser ViaInfo -&gt; Parser ViaInfo
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-103"></span><span>        </span><span class="annot"><span class="annottext">[Char] -&gt; [Char] -&gt; ViaInfo
</span><a href="Data.Serde.Internal.ISyn.html#WithVia"><span class="hs-identifier hs-var">WithVia</span></a></span><span>
</span><span id="line-104"></span><span>          </span><span class="annot"><span class="annottext">([Char] -&gt; [Char] -&gt; ViaInfo)
-&gt; Parser [Char]
-&gt; ParsecT Void [Char] Identity ([Char] -&gt; ViaInfo)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser [Char] -&gt; Parser [Char]
forall a. Parser a -&gt; Parser a
</span><a href="Data.Serde.Internal.ISyn.html#lexeme"><span class="hs-identifier hs-var">lexeme</span></a></span><span> </span><span class="annot"><span class="annottext">Parser [Char]
</span><a href="Data.Serde.Internal.ISyn.html#untilvia"><span class="hs-identifier hs-var">untilvia</span></a></span><span>
</span><span id="line-105"></span><span>          </span><span class="annot"><span class="annottext">ParsecT Void [Char] Identity ([Char] -&gt; ViaInfo)
-&gt; Parser [Char] -&gt; Parser ViaInfo
forall a b.
ParsecT Void [Char] Identity (a -&gt; b)
-&gt; ParsecT Void [Char] Identity a -&gt; ParsecT Void [Char] Identity b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ParsecT Void [Char] Identity (Tokens [Char])
-&gt; ParsecT Void [Char] Identity (Tokens [Char])
forall a. Parser a -&gt; Parser a
</span><a href="Data.Serde.Internal.ISyn.html#lexeme"><span class="hs-identifier hs-var">lexeme</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Tokens [Char] -&gt; ParsecT Void [Char] Identity (Tokens [Char])
forall e s (m :: * -&gt; *).
MonadParsec e s m =&gt;
Tokens s -&gt; m (Tokens s)
</span><span class="hs-identifier hs-var">M.string</span></span><span> </span><span class="annot"><span class="annottext">[Char]
Tokens [Char]
</span><span class="hs-string">&quot;via&quot;</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">ParsecT Void [Char] Identity (Tokens [Char])
-&gt; Parser [Char] -&gt; Parser [Char]
forall a b.
ParsecT Void [Char] Identity a
-&gt; ParsecT Void [Char] Identity b -&gt; ParsecT Void [Char] Identity b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser [Char] -&gt; Parser [Char]
forall a. Parser a -&gt; Parser a
</span><a href="Data.Serde.Internal.ISyn.html#lexeme"><span class="hs-identifier hs-var">lexeme</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ParsecT Void [Char] Identity Char -&gt; Parser [Char]
</span><a href="Data.Serde.Internal.ISyn.html#untileol"><span class="hs-identifier hs-var">untileol</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT Void [Char] Identity Char
ParsecT Void [Char] Identity (Token [Char])
forall e s (m :: * -&gt; *). MonadParsec e s m =&gt; m (Token s)
</span><span class="hs-identifier hs-var">M.anySingle</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-106"></span><span>      </span><span class="annot"><span class="annottext">[Char] -&gt; ViaInfo
</span><a href="Data.Serde.Internal.ISyn.html#Plain"><span class="hs-identifier hs-var">Plain</span></a></span><span> </span><span class="annot"><span class="annottext">([Char] -&gt; ViaInfo) -&gt; Parser [Char] -&gt; Parser ViaInfo
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser [Char] -&gt; Parser [Char]
forall a. Parser a -&gt; Parser a
</span><a href="Data.Serde.Internal.ISyn.html#lexeme"><span class="hs-identifier hs-var">lexeme</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ParsecT Void [Char] Identity Char -&gt; Parser [Char]
</span><a href="Data.Serde.Internal.ISyn.html#untileol"><span class="hs-identifier hs-var">untileol</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT Void [Char] Identity Char
ParsecT Void [Char] Identity (Token [Char])
forall e s (m :: * -&gt; *). MonadParsec e s m =&gt; m (Token s)
</span><span class="hs-identifier hs-var">M.anySingle</span></span><span class="hs-special">)</span><span>
</span><span id="line-107"></span><span>    </span><span class="hs-special">]</span><span>
</span><span id="line-108"></span><span>
</span><span id="line-109"></span><span class="annot"><a href="Data.Serde.Internal.ISyn.html#parsefield"><span class="hs-identifier hs-type">parsefield</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.Serde.Internal.ISyn.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Data.Serde.Internal.ISyn.html#ISynFld"><span class="hs-identifier hs-type">ISynFld</span></a></span><span>
</span><span id="line-110"></span><span id="parsefield"><span class="annot"><span class="annottext">parsefield :: Parser ISynFld
</span><a href="Data.Serde.Internal.ISyn.html#parsefield"><span class="hs-identifier hs-var hs-var">parsefield</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-111"></span><span>  </span><span id="local-6989586621679116299"><span class="annot"><span class="annottext">[Char]
</span><a href="#local-6989586621679116299"><span class="hs-identifier hs-var">isfldnam</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Parser [Char] -&gt; Parser [Char]
forall a. Parser a -&gt; Parser a
</span><a href="Data.Serde.Internal.ISyn.html#lexeme"><span class="hs-identifier hs-var">lexeme</span></a></span><span> </span><span class="annot"><span class="annottext">Parser [Char]
</span><a href="Data.Serde.Internal.ISyn.html#identifier"><span class="hs-identifier hs-var">identifier</span></a></span><span>
</span><span id="line-112"></span><span>  </span><span class="annot"><span class="annottext">ParsecT Void [Char] Identity (Tokens [Char]) -&gt; Parser ()
forall (f :: * -&gt; *) a. Functor f =&gt; f a -&gt; f ()
</span><span class="hs-identifier hs-var">void</span></span><span> </span><span class="annot"><span class="annottext">(ParsecT Void [Char] Identity (Tokens [Char]) -&gt; Parser ())
-&gt; ParsecT Void [Char] Identity (Tokens [Char]) -&gt; Parser ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">ParsecT Void [Char] Identity (Tokens [Char])
-&gt; ParsecT Void [Char] Identity (Tokens [Char])
forall a. Parser a -&gt; Parser a
</span><a href="Data.Serde.Internal.ISyn.html#lexeme"><span class="hs-identifier hs-var">lexeme</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Tokens [Char] -&gt; ParsecT Void [Char] Identity (Tokens [Char])
forall e s (m :: * -&gt; *).
MonadParsec e s m =&gt;
Tokens s -&gt; m (Tokens s)
</span><span class="hs-identifier hs-var">M.string</span></span><span> </span><span class="annot"><span class="annottext">[Char]
Tokens [Char]
</span><span class="hs-string">&quot;::&quot;</span></span><span class="hs-special">)</span><span>
</span><span id="line-113"></span><span>  </span><span id="local-6989586621679116300"><span class="annot"><span class="annottext">ViaInfo
</span><a href="#local-6989586621679116300"><span class="hs-identifier hs-var">isfldtyp</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Parser ViaInfo
</span><a href="Data.Serde.Internal.ISyn.html#parsetype"><span class="hs-identifier hs-var">parsetype</span></a></span><span>
</span><span id="line-114"></span><span>  </span><span class="annot"><span class="annottext">ISynFld -&gt; Parser ISynFld
forall a. a -&gt; ParsecT Void [Char] Identity a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><a href="Data.Serde.Internal.ISyn.html#ISynFld"><span class="hs-identifier hs-type">ISynFld</span></a></span><span> </span><span class="hs-special">{</span><span class="annot"><span class="annottext">[Char]
isfldnam :: [Char]
isfldnam :: [Char]
</span><a href="Data.Serde.Internal.ISyn.html#isfldnam"><span class="hs-identifier hs-var hs-var">isfldnam</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ViaInfo
isfldtyp :: ViaInfo
isfldtyp :: ViaInfo
</span><a href="Data.Serde.Internal.ISyn.html#isfldtyp"><span class="hs-identifier hs-var hs-var">isfldtyp</span></a></span><span class="hs-special">}</span><span>
</span><span id="line-115"></span><span>
</span><span id="line-116"></span><span id="local-6989586621679115987"><span id="local-6989586621679115988"><span class="annot"><a href="Data.Serde.Internal.ISyn.html#indentblock"><span class="hs-identifier hs-type">indentblock</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.Serde.Internal.ISyn.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679115987"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Serde.Internal.ISyn.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679115988"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Serde.Internal.ISyn.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679115987"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679115988"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span></span></span><span>
</span><span id="line-117"></span><span id="indentblock"><span class="annot"><span class="annottext">indentblock :: forall a b. Parser a -&gt; Parser b -&gt; Parser (a, [b])
</span><a href="Data.Serde.Internal.ISyn.html#indentblock"><span class="hs-identifier hs-var hs-var">indentblock</span></a></span></span><span> </span><span id="local-6989586621679116309"><span class="annot"><span class="annottext">Parser a
</span><a href="#local-6989586621679116309"><span class="hs-identifier hs-var">p1</span></a></span></span><span> </span><span id="local-6989586621679116310"><span class="annot"><span class="annottext">Parser b
</span><a href="#local-6989586621679116310"><span class="hs-identifier hs-var">p2</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parser ()
-&gt; ParsecT
     Void
     [Char]
     Identity
     (IndentOpt (ParsecT Void [Char] Identity) (a, [b]) b)
-&gt; ParsecT Void [Char] Identity (a, [b])
forall s e (m :: * -&gt; *) a b.
(TraversableStream s, MonadParsec e s m, Token s ~ Char) =&gt;
m () -&gt; m (IndentOpt m a b) -&gt; m a
</span><span class="hs-identifier hs-var">L.indentBlock</span></span><span> </span><span class="annot"><span class="annottext">Parser ()
</span><a href="Data.Serde.Internal.ISyn.html#sc"><span class="hs-identifier hs-var">sc</span></a></span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-118"></span><span>  </span><span id="local-6989586621679116312"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679116312"><span class="hs-identifier hs-var">i</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Parser a
</span><a href="#local-6989586621679116309"><span class="hs-identifier hs-var">p1</span></a></span><span>
</span><span id="line-119"></span><span>  </span><span class="annot"><span class="annottext">IndentOpt (ParsecT Void [Char] Identity) (a, [b]) b
-&gt; ParsecT
     Void
     [Char]
     Identity
     (IndentOpt (ParsecT Void [Char] Identity) (a, [b]) b)
forall a. a -&gt; ParsecT Void [Char] Identity a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">(IndentOpt (ParsecT Void [Char] Identity) (a, [b]) b
 -&gt; ParsecT
      Void
      [Char]
      Identity
      (IndentOpt (ParsecT Void [Char] Identity) (a, [b]) b))
-&gt; IndentOpt (ParsecT Void [Char] Identity) (a, [b]) b
-&gt; ParsecT
     Void
     [Char]
     Identity
     (IndentOpt (ParsecT Void [Char] Identity) (a, [b]) b)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Maybe Pos
-&gt; ([b] -&gt; ParsecT Void [Char] Identity (a, [b]))
-&gt; Parser b
-&gt; IndentOpt (ParsecT Void [Char] Identity) (a, [b]) b
forall (m :: * -&gt; *) a b.
Maybe Pos -&gt; ([b] -&gt; m a) -&gt; m b -&gt; IndentOpt m a b
</span><span class="hs-identifier hs-var">L.IndentMany</span></span><span> </span><span class="annot"><span class="annottext">Maybe Pos
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(a, [b]) -&gt; ParsecT Void [Char] Identity (a, [b])
forall a. a -&gt; ParsecT Void [Char] Identity a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">((a, [b]) -&gt; ParsecT Void [Char] Identity (a, [b]))
-&gt; ([b] -&gt; (a, [b]))
-&gt; [b]
-&gt; ParsecT Void [Char] Identity (a, [b])
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679116312"><span class="hs-identifier hs-var">i</span></a></span><span class="hs-special">,</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Parser b
</span><a href="#local-6989586621679116310"><span class="hs-identifier hs-var">p2</span></a></span><span>
</span><span id="line-120"></span><span>
</span><span id="line-121"></span><span class="annot"><a href="Data.Serde.Internal.ISyn.html#parsedata"><span class="hs-identifier hs-type">parsedata</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.Serde.Internal.ISyn.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Data.Serde.Internal.ISyn.html#ISyn"><span class="hs-identifier hs-type">ISyn</span></a></span><span>
</span><span id="line-122"></span><span id="parsedata"><span class="annot"><span class="annottext">parsedata :: Parser ISyn
</span><a href="Data.Serde.Internal.ISyn.html#parsedata"><span class="hs-identifier hs-var hs-var">parsedata</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-123"></span><span>  </span><span class="hs-special">(</span><span id="local-6989586621679116315"><span class="annot"><span class="annottext">[Char]
</span><a href="#local-6989586621679116315"><span class="hs-identifier hs-var">isnam</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679116316"><span class="annot"><span class="annottext">[ISynFld]
</span><a href="#local-6989586621679116316"><span class="hs-identifier hs-var">isflds</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span>
</span><span id="line-124"></span><span>    </span><span class="annot"><span class="annottext">Parser [Char] -&gt; Parser ISynFld -&gt; Parser ([Char], [ISynFld])
forall a b. Parser a -&gt; Parser b -&gt; Parser (a, [b])
</span><a href="Data.Serde.Internal.ISyn.html#indentblock"><span class="hs-identifier hs-var">indentblock</span></a></span><span>
</span><span id="line-125"></span><span>      </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ParsecT Void [Char] Identity (Tokens [Char])
-&gt; ParsecT Void [Char] Identity (Tokens [Char])
forall a. Parser a -&gt; Parser a
</span><a href="Data.Serde.Internal.ISyn.html#lexeme"><span class="hs-identifier hs-var">lexeme</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Tokens [Char] -&gt; ParsecT Void [Char] Identity (Tokens [Char])
forall e s (m :: * -&gt; *).
MonadParsec e s m =&gt;
Tokens s -&gt; m (Tokens s)
</span><span class="hs-identifier hs-var">M.string</span></span><span> </span><span class="annot"><span class="annottext">[Char]
Tokens [Char]
</span><span class="hs-string">&quot;data&quot;</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">ParsecT Void [Char] Identity (Tokens [Char])
-&gt; Parser [Char] -&gt; Parser [Char]
forall a b.
ParsecT Void [Char] Identity a
-&gt; ParsecT Void [Char] Identity b -&gt; ParsecT Void [Char] Identity b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser [Char] -&gt; Parser [Char]
forall a. Parser a -&gt; Parser a
</span><a href="Data.Serde.Internal.ISyn.html#lexeme"><span class="hs-identifier hs-var">lexeme</span></a></span><span> </span><span class="annot"><span class="annottext">Parser [Char]
</span><a href="Data.Serde.Internal.ISyn.html#identifier"><span class="hs-identifier hs-var">identifier</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-126"></span><span>      </span><span class="annot"><span class="annottext">Parser ISynFld
</span><a href="Data.Serde.Internal.ISyn.html#parsefield"><span class="hs-identifier hs-var">parsefield</span></a></span><span>
</span><span id="line-127"></span><span>  </span><span class="annot"><span class="annottext">ISyn -&gt; Parser ISyn
forall a. a -&gt; ParsecT Void [Char] Identity a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><a href="Data.Serde.Internal.ISyn.html#ISynData"><span class="hs-identifier hs-type">ISynData</span></a></span><span> </span><span class="hs-special">{</span><span class="annot"><span class="annottext">[Char]
isnam :: [Char]
isnam :: [Char]
</span><a href="Data.Serde.Internal.ISyn.html#isnam"><span class="hs-identifier hs-var hs-var">isnam</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[ISynFld]
isflds :: [ISynFld]
isflds :: [ISynFld]
</span><a href="Data.Serde.Internal.ISyn.html#isflds"><span class="hs-identifier hs-var hs-var">isflds</span></a></span><span class="hs-special">}</span><span>
</span><span id="line-128"></span><span>
</span><span id="line-129"></span><span class="annot"><a href="Data.Serde.Internal.ISyn.html#parsenewtype"><span class="hs-identifier hs-type">parsenewtype</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.Serde.Internal.ISyn.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Data.Serde.Internal.ISyn.html#ISyn"><span class="hs-identifier hs-type">ISyn</span></a></span><span>
</span><span id="line-130"></span><span id="parsenewtype"><span class="annot"><span class="annottext">parsenewtype :: Parser ISyn
</span><a href="Data.Serde.Internal.ISyn.html#parsenewtype"><span class="hs-identifier hs-var hs-var">parsenewtype</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parser ISyn -&gt; Parser ISyn
forall a. Parser a -&gt; Parser a
forall e s (m :: * -&gt; *) a. MonadParsec e s m =&gt; m a -&gt; m a
</span><span class="hs-identifier hs-var">M.try</span></span><span> </span><span class="annot"><span class="annottext">Parser ISyn
</span><a href="#local-6989586621679116318"><span class="hs-identifier hs-var">parsenewtype1</span></a></span><span> </span><span class="annot"><span class="annottext">Parser ISyn -&gt; Parser ISyn -&gt; Parser ISyn
forall a.
ParsecT Void [Char] Identity a
-&gt; ParsecT Void [Char] Identity a -&gt; ParsecT Void [Char] Identity a
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f a -&gt; f a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser ISyn
</span><a href="#local-6989586621679116319"><span class="hs-identifier hs-var">parsenewtype2</span></a></span><span>
</span><span id="line-131"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-132"></span><span>    </span><span id="local-6989586621679116318"><span class="annot"><span class="annottext">parsenewtype1 :: Parser ISyn
</span><a href="#local-6989586621679116318"><span class="hs-identifier hs-var hs-var">parsenewtype1</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-133"></span><span>      </span><span class="hs-special">(</span><span id="local-6989586621679116331"><span class="annot"><span class="annottext">[Char]
</span><a href="#local-6989586621679116331"><span class="hs-identifier hs-var">isnam</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679116332"><span class="annot"><span class="annottext">[ISynFld]
</span><a href="#local-6989586621679116332"><span class="hs-identifier hs-var">flds</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span>
</span><span id="line-134"></span><span>        </span><span class="annot"><span class="annottext">Parser [Char] -&gt; Parser ISynFld -&gt; Parser ([Char], [ISynFld])
forall a b. Parser a -&gt; Parser b -&gt; Parser (a, [b])
</span><a href="Data.Serde.Internal.ISyn.html#indentblock"><span class="hs-identifier hs-var">indentblock</span></a></span><span>
</span><span id="line-135"></span><span>          </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ParsecT Void [Char] Identity (Tokens [Char])
-&gt; ParsecT Void [Char] Identity (Tokens [Char])
forall a. Parser a -&gt; Parser a
</span><a href="Data.Serde.Internal.ISyn.html#lexeme"><span class="hs-identifier hs-var">lexeme</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Tokens [Char] -&gt; ParsecT Void [Char] Identity (Tokens [Char])
forall e s (m :: * -&gt; *).
MonadParsec e s m =&gt;
Tokens s -&gt; m (Tokens s)
</span><span class="hs-identifier hs-var">M.string</span></span><span> </span><span class="annot"><span class="annottext">[Char]
Tokens [Char]
</span><span class="hs-string">&quot;newtype&quot;</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">ParsecT Void [Char] Identity (Tokens [Char])
-&gt; Parser [Char] -&gt; Parser [Char]
forall a b.
ParsecT Void [Char] Identity a
-&gt; ParsecT Void [Char] Identity b -&gt; ParsecT Void [Char] Identity b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser [Char] -&gt; Parser [Char]
forall a. Parser a -&gt; Parser a
</span><a href="Data.Serde.Internal.ISyn.html#lexeme"><span class="hs-identifier hs-var">lexeme</span></a></span><span> </span><span class="annot"><span class="annottext">Parser [Char]
</span><a href="Data.Serde.Internal.ISyn.html#identifier"><span class="hs-identifier hs-var">identifier</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-136"></span><span>          </span><span class="annot"><span class="annottext">Parser ISynFld
</span><a href="Data.Serde.Internal.ISyn.html#parsefield"><span class="hs-identifier hs-var">parsefield</span></a></span><span>
</span><span id="line-137"></span><span>      </span><span id="local-6989586621679116333"><span class="annot"><span class="annottext">ISynFld
</span><a href="#local-6989586621679116333"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">[ISynFld]
</span><a href="#local-6989586621679116332"><span class="hs-identifier hs-var">flds</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-138"></span><span>        </span><span class="hs-special">[</span><span id="local-6989586621679116334"><span class="annot"><span class="annottext">ISynFld
</span><a href="#local-6989586621679116334"><span class="hs-identifier hs-var">g</span></a></span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">ISynFld -&gt; Parser ISynFld
forall a. a -&gt; ParsecT Void [Char] Identity a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">ISynFld
</span><a href="#local-6989586621679116334"><span class="hs-identifier hs-var">g</span></a></span><span>
</span><span id="line-139"></span><span>        </span><span class="annot"><span class="annottext">[ISynFld]
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">[Char] -&gt; Parser ISynFld
forall a. [Char] -&gt; ParsecT Void [Char] Identity a
forall (m :: * -&gt; *) a. MonadFail m =&gt; [Char] -&gt; m a
</span><span class="hs-identifier hs-var">fail</span></span><span> </span><span class="annot"><span class="annottext">[Char]
</span><span class="hs-string">&quot;parsenewtype: a newtype must have exactly one field&quot;</span></span><span>
</span><span id="line-140"></span><span>      </span><span class="annot"><span class="annottext">ISyn -&gt; Parser ISyn
forall a. a -&gt; ParsecT Void [Char] Identity a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><a href="Data.Serde.Internal.ISyn.html#ISynNewtype"><span class="hs-identifier hs-type">ISynNewtype</span></a></span><span> </span><span class="hs-special">{</span><span class="annot"><span class="annottext">[Char]
isnam :: [Char]
isnam :: [Char]
</span><a href="Data.Serde.Internal.ISyn.html#isnam"><span class="hs-identifier hs-var hs-var">isnam</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">isfld1 :: INewtypePayload
</span><a href="Data.Serde.Internal.ISyn.html#isfld1"><span class="hs-identifier hs-var">isfld1</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ISynFld -&gt; INewtypePayload
</span><a href="Data.Serde.Internal.ISyn.html#IField"><span class="hs-identifier hs-var">IField</span></a></span><span> </span><span class="annot"><span class="annottext">ISynFld
</span><a href="#local-6989586621679116333"><span class="hs-identifier hs-var">f</span></a></span><span class="hs-special">}</span><span>
</span><span id="line-141"></span><span>    </span><span id="local-6989586621679116319"><span class="annot"><span class="annottext">parsenewtype2 :: Parser ISyn
</span><a href="#local-6989586621679116319"><span class="hs-identifier hs-var hs-var">parsenewtype2</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-142"></span><span>      </span><span class="annot"><span class="annottext">ParsecT Void [Char] Identity (Tokens [Char]) -&gt; Parser ()
forall (f :: * -&gt; *) a. Functor f =&gt; f a -&gt; f ()
</span><span class="hs-identifier hs-var">void</span></span><span> </span><span class="annot"><span class="annottext">(ParsecT Void [Char] Identity (Tokens [Char]) -&gt; Parser ())
-&gt; ParsecT Void [Char] Identity (Tokens [Char]) -&gt; Parser ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">ParsecT Void [Char] Identity (Tokens [Char])
-&gt; ParsecT Void [Char] Identity (Tokens [Char])
forall a. Parser a -&gt; Parser a
</span><a href="Data.Serde.Internal.ISyn.html#lexeme"><span class="hs-identifier hs-var">lexeme</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Tokens [Char] -&gt; ParsecT Void [Char] Identity (Tokens [Char])
forall e s (m :: * -&gt; *).
MonadParsec e s m =&gt;
Tokens s -&gt; m (Tokens s)
</span><span class="hs-identifier hs-var">M.string</span></span><span> </span><span class="annot"><span class="annottext">[Char]
Tokens [Char]
</span><span class="hs-string">&quot;newtype&quot;</span></span><span class="hs-special">)</span><span>
</span><span id="line-143"></span><span>      </span><span id="local-6989586621679116344"><span class="annot"><span class="annottext">[Char]
</span><a href="#local-6989586621679116344"><span class="hs-identifier hs-var">isnam</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Parser [Char] -&gt; Parser [Char]
forall a. Parser a -&gt; Parser a
</span><a href="Data.Serde.Internal.ISyn.html#lexeme"><span class="hs-identifier hs-var">lexeme</span></a></span><span> </span><span class="annot"><span class="annottext">Parser [Char]
</span><a href="Data.Serde.Internal.ISyn.html#identifier"><span class="hs-identifier hs-var">identifier</span></a></span><span>
</span><span id="line-144"></span><span>      </span><span id="local-6989586621679116345"><span class="annot"><span class="annottext">ViaInfo
</span><a href="#local-6989586621679116345"><span class="hs-identifier hs-var">typ</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Parser ViaInfo
</span><a href="Data.Serde.Internal.ISyn.html#parsetype"><span class="hs-identifier hs-var">parsetype</span></a></span><span>
</span><span id="line-145"></span><span>      </span><span class="annot"><span class="annottext">ISyn -&gt; Parser ISyn
forall a. a -&gt; ParsecT Void [Char] Identity a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><a href="Data.Serde.Internal.ISyn.html#ISynNewtype"><span class="hs-identifier hs-type">ISynNewtype</span></a></span><span> </span><span class="hs-special">{</span><span class="annot"><span class="annottext">[Char]
isnam :: [Char]
isnam :: [Char]
</span><a href="Data.Serde.Internal.ISyn.html#isnam"><span class="hs-identifier hs-var hs-var">isnam</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">isfld1 :: INewtypePayload
</span><a href="Data.Serde.Internal.ISyn.html#isfld1"><span class="hs-identifier hs-var">isfld1</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ViaInfo -&gt; INewtypePayload
</span><a href="Data.Serde.Internal.ISyn.html#IType"><span class="hs-identifier hs-var">IType</span></a></span><span> </span><span class="annot"><span class="annottext">ViaInfo
</span><a href="#local-6989586621679116345"><span class="hs-identifier hs-var">typ</span></a></span><span class="hs-special">}</span><span>
</span><span id="line-146"></span><span>
</span><span id="line-147"></span><span class="annot"><a href="Data.Serde.Internal.ISyn.html#parsealias"><span class="hs-identifier hs-type">parsealias</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.Serde.Internal.ISyn.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Data.Serde.Internal.ISyn.html#ISyn"><span class="hs-identifier hs-type">ISyn</span></a></span><span>
</span><span id="line-148"></span><span id="parsealias"><span class="annot"><span class="annottext">parsealias :: Parser ISyn
</span><a href="Data.Serde.Internal.ISyn.html#parsealias"><span class="hs-identifier hs-var hs-var">parsealias</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-149"></span><span>  </span><span class="annot"><span class="annottext">ParsecT Void [Char] Identity (Tokens [Char]) -&gt; Parser ()
forall (f :: * -&gt; *) a. Functor f =&gt; f a -&gt; f ()
</span><span class="hs-identifier hs-var">void</span></span><span> </span><span class="annot"><span class="annottext">(ParsecT Void [Char] Identity (Tokens [Char]) -&gt; Parser ())
-&gt; ParsecT Void [Char] Identity (Tokens [Char]) -&gt; Parser ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">ParsecT Void [Char] Identity (Tokens [Char])
-&gt; ParsecT Void [Char] Identity (Tokens [Char])
forall a. Parser a -&gt; Parser a
</span><a href="Data.Serde.Internal.ISyn.html#lexeme"><span class="hs-identifier hs-var">lexeme</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Tokens [Char] -&gt; ParsecT Void [Char] Identity (Tokens [Char])
forall e s (m :: * -&gt; *).
MonadParsec e s m =&gt;
Tokens s -&gt; m (Tokens s)
</span><span class="hs-identifier hs-var">M.string</span></span><span> </span><span class="annot"><span class="annottext">[Char]
Tokens [Char]
</span><span class="hs-string">&quot;type&quot;</span></span><span class="hs-special">)</span><span>
</span><span id="line-150"></span><span>  </span><span id="local-6989586621679116347"><span class="annot"><span class="annottext">[Char]
</span><a href="#local-6989586621679116347"><span class="hs-identifier hs-var">isnam</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Parser [Char] -&gt; Parser [Char]
forall a. Parser a -&gt; Parser a
</span><a href="Data.Serde.Internal.ISyn.html#lexeme"><span class="hs-identifier hs-var">lexeme</span></a></span><span> </span><span class="annot"><span class="annottext">Parser [Char]
</span><a href="Data.Serde.Internal.ISyn.html#identifier"><span class="hs-identifier hs-var">identifier</span></a></span><span>
</span><span id="line-151"></span><span>  </span><span id="local-6989586621679116348"><span class="annot"><span class="annottext">[Char]
</span><a href="#local-6989586621679116348"><span class="hs-identifier hs-var">isdest</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Parser [Char] -&gt; Parser [Char]
forall a. Parser a -&gt; Parser a
</span><a href="Data.Serde.Internal.ISyn.html#lexeme"><span class="hs-identifier hs-var">lexeme</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ParsecT Void [Char] Identity Char -&gt; Parser [Char]
</span><a href="Data.Serde.Internal.ISyn.html#untileol"><span class="hs-identifier hs-var">untileol</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT Void [Char] Identity Char
ParsecT Void [Char] Identity (Token [Char])
forall e s (m :: * -&gt; *). MonadParsec e s m =&gt; m (Token s)
</span><span class="hs-identifier hs-var">M.anySingle</span></span><span class="hs-special">)</span><span>
</span><span id="line-152"></span><span>  </span><span class="annot"><span class="annottext">ISyn -&gt; Parser ISyn
forall a. a -&gt; ParsecT Void [Char] Identity a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><a href="Data.Serde.Internal.ISyn.html#ISynAlias"><span class="hs-identifier hs-type">ISynAlias</span></a></span><span> </span><span class="hs-special">{</span><span class="annot"><span class="annottext">[Char]
isnam :: [Char]
isnam :: [Char]
</span><a href="Data.Serde.Internal.ISyn.html#isnam"><span class="hs-identifier hs-var hs-var">isnam</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[Char]
isdest :: [Char]
isdest :: [Char]
</span><a href="Data.Serde.Internal.ISyn.html#isdest"><span class="hs-identifier hs-var hs-var">isdest</span></a></span><span class="hs-special">}</span><span>
</span><span id="line-153"></span><span>
</span><span id="line-154"></span><span class="annot"><a href="Data.Serde.Internal.ISyn.html#parsederive"><span class="hs-identifier hs-type">parsederive</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.Serde.Internal.ISyn.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Data.Serde.Internal.ISyn.html#Derive"><span class="hs-identifier hs-type">Derive</span></a></span><span>
</span><span id="line-155"></span><span id="parsederive"><span class="annot"><span class="annottext">parsederive :: Parser Derive
</span><a href="Data.Serde.Internal.ISyn.html#parsederive"><span class="hs-identifier hs-var hs-var">parsederive</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-156"></span><span>  </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Tokens [Char]
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span class="hs-glyph">!</span><span id="local-6989586621679116350"><span class="annot"><span class="annottext">[[[Char]]]
</span><a href="#local-6989586621679116350"><span class="hs-identifier hs-var">classes</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span>
</span><span id="line-157"></span><span>    </span><span class="annot"><span class="annottext">ParsecT Void [Char] Identity (Tokens [Char])
-&gt; Parser [[Char]] -&gt; Parser (Tokens [Char], [[[Char]]])
forall a b. Parser a -&gt; Parser b -&gt; Parser (a, [b])
</span><a href="Data.Serde.Internal.ISyn.html#indentblock"><span class="hs-identifier hs-var">indentblock</span></a></span><span>
</span><span id="line-158"></span><span>      </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ParsecT Void [Char] Identity (Tokens [Char])
-&gt; ParsecT Void [Char] Identity (Tokens [Char])
forall a. Parser a -&gt; Parser a
</span><a href="Data.Serde.Internal.ISyn.html#lexeme"><span class="hs-identifier hs-var">lexeme</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Tokens [Char] -&gt; ParsecT Void [Char] Identity (Tokens [Char])
forall e s (m :: * -&gt; *).
MonadParsec e s m =&gt;
Tokens s -&gt; m (Tokens s)
</span><span class="hs-identifier hs-var">M.string</span></span><span> </span><span class="annot"><span class="annottext">[Char]
Tokens [Char]
</span><span class="hs-string">&quot;.derive&quot;</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-159"></span><span>      </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parser [Char] -&gt; Parser [[Char]]
forall (m :: * -&gt; *) a. MonadPlus m =&gt; m a -&gt; m [a]
</span><span class="hs-identifier hs-var">many</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parser [Char] -&gt; Parser [Char]
forall a. Parser a -&gt; Parser a
</span><a href="Data.Serde.Internal.ISyn.html#lexeme"><span class="hs-identifier hs-var">lexeme</span></a></span><span> </span><span class="annot"><span class="annottext">Parser [Char]
</span><a href="Data.Serde.Internal.ISyn.html#identifier"><span class="hs-identifier hs-var">identifier</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-160"></span><span>  </span><span class="annot"><span class="annottext">Derive -&gt; Parser Derive
forall a. a -&gt; ParsecT Void [Char] Identity a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">(Derive -&gt; Parser Derive) -&gt; Derive -&gt; Parser Derive
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[[Char]] -&gt; Derive
</span><a href="Data.Serde.Internal.ISyn.html#Derive"><span class="hs-identifier hs-var">Derive</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[[[Char]]] -&gt; [[Char]]
forall (m :: * -&gt; *) a. Monad m =&gt; m (m a) -&gt; m a
</span><span class="hs-identifier hs-var">join</span></span><span> </span><span class="annot"><span class="annottext">[[[Char]]]
</span><a href="#local-6989586621679116350"><span class="hs-identifier hs-var">classes</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-161"></span><span>
</span><span id="line-162"></span><span class="annot"><a href="Data.Serde.Internal.ISyn.html#parsesyn"><span class="hs-identifier hs-type">parsesyn</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.Serde.Internal.ISyn.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Data.Serde.Internal.ISyn.html#ISyn"><span class="hs-identifier hs-type">ISyn</span></a></span><span>
</span><span id="line-163"></span><span id="parsesyn"><span class="annot"><span class="annottext">parsesyn :: Parser ISyn
</span><a href="Data.Serde.Internal.ISyn.html#parsesyn"><span class="hs-identifier hs-var hs-var">parsesyn</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-164"></span><span>  </span><span class="annot"><span class="annottext">Parser ISyn -&gt; Parser ISyn
forall a. Parser a -&gt; Parser a
forall e s (m :: * -&gt; *) a. MonadParsec e s m =&gt; m a -&gt; m a
</span><span class="hs-identifier hs-var">M.try</span></span><span> </span><span class="annot"><span class="annottext">(Parser ISyn -&gt; Parser ISyn) -&gt; Parser ISyn -&gt; Parser ISyn
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-165"></span><span>    </span><span class="annot"><span class="annottext">[Parser ISyn] -&gt; Parser ISyn
forall (f :: * -&gt; *) (m :: * -&gt; *) a.
(Foldable f, Alternative m) =&gt;
f (m a) -&gt; m a
</span><span class="hs-identifier hs-var">M.choice</span></span><span>
</span><span id="line-166"></span><span>      </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">Parser ISyn -&gt; Parser ISyn
forall a. Parser a -&gt; Parser a
forall e s (m :: * -&gt; *) a. MonadParsec e s m =&gt; m a -&gt; m a
</span><span class="hs-identifier hs-var">M.try</span></span><span> </span><span class="annot"><span class="annottext">Parser ISyn
</span><a href="Data.Serde.Internal.ISyn.html#parsedata"><span class="hs-identifier hs-var">parsedata</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-167"></span><span>        </span><span class="annot"><span class="annottext">Parser ISyn -&gt; Parser ISyn
forall a. Parser a -&gt; Parser a
forall e s (m :: * -&gt; *) a. MonadParsec e s m =&gt; m a -&gt; m a
</span><span class="hs-identifier hs-var">M.try</span></span><span> </span><span class="annot"><span class="annottext">Parser ISyn
</span><a href="Data.Serde.Internal.ISyn.html#parsenewtype"><span class="hs-identifier hs-var">parsenewtype</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-168"></span><span>        </span><span class="annot"><span class="annottext">Parser ISyn -&gt; Parser ISyn
forall a. Parser a -&gt; Parser a
forall e s (m :: * -&gt; *) a. MonadParsec e s m =&gt; m a -&gt; m a
</span><span class="hs-identifier hs-var">M.try</span></span><span> </span><span class="annot"><span class="annottext">Parser ISyn
</span><a href="Data.Serde.Internal.ISyn.html#parsealias"><span class="hs-identifier hs-var">parsealias</span></a></span><span>
</span><span id="line-169"></span><span>      </span><span class="hs-special">]</span><span>
</span><span id="line-170"></span><span>
</span><span id="line-171"></span><span class="annot"><a href="Data.Serde.Internal.ISyn.html#parsetop"><span class="hs-identifier hs-type">parsetop</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.Serde.Internal.ISyn.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.Serde.Internal.ISyn.html#Derive"><span class="hs-identifier hs-type">Derive</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Data.Serde.Internal.ISyn.html#ISyn"><span class="hs-identifier hs-type">ISyn</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-172"></span><span id="parsetop"><span class="annot"><span class="annottext">parsetop :: Parser (Derive, [ISyn])
</span><a href="Data.Serde.Internal.ISyn.html#parsetop"><span class="hs-identifier hs-var hs-var">parsetop</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-173"></span><span>  </span><span id="local-6989586621679116352"><span class="annot"><span class="annottext">Derive
</span><a href="#local-6989586621679116352"><span class="hs-identifier hs-var">h</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Parser Derive
</span><a href="Data.Serde.Internal.ISyn.html#parsederive"><span class="hs-identifier hs-var">parsederive</span></a></span><span>
</span><span id="line-174"></span><span>  </span><span id="local-6989586621679116353"><span class="annot"><span class="annottext">[ISyn]
</span><a href="#local-6989586621679116353"><span class="hs-identifier hs-var">decls</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Parser ISyn
</span><a href="Data.Serde.Internal.ISyn.html#parsesyn"><span class="hs-identifier hs-var">parsesyn</span></a></span><span> </span><span class="annot"><span class="annottext">Parser ISyn -&gt; Parser () -&gt; ParsecT Void [Char] Identity [ISyn]
forall (m :: * -&gt; *) a end. MonadPlus m =&gt; m a -&gt; m end -&gt; m [a]
</span><span class="hs-operator hs-var">`M.sepEndBy1`</span></span><span> </span><span class="annot"><span class="annottext">Parser ()
forall e s (m :: * -&gt; *).
(MonadParsec e s m, Token s ~ Char) =&gt;
m ()
</span><span class="hs-identifier hs-var">M.space</span></span><span>
</span><span id="line-175"></span><span>  </span><span class="annot"><span class="annottext">Parser ()
forall e s (m :: * -&gt; *). MonadParsec e s m =&gt; m ()
</span><span class="hs-identifier hs-var">M.eof</span></span><span>
</span><span id="line-176"></span><span>  </span><span class="annot"><span class="annottext">(Derive, [ISyn]) -&gt; Parser (Derive, [ISyn])
forall a. a -&gt; ParsecT Void [Char] Identity a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Derive
</span><a href="#local-6989586621679116352"><span class="hs-identifier hs-var">h</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[ISyn]
</span><a href="#local-6989586621679116353"><span class="hs-identifier hs-var">decls</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-177"></span><span>
</span><span id="line-178"></span><span class="hs-comment">-- test (when using GHCi)</span><span>
</span><span id="line-179"></span><span class="annot"><a href="Data.Serde.Internal.ISyn.html#_testbody1"><span class="hs-identifier hs-type">_testbody1</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>
</span><span id="line-180"></span><span id="_testbody1"><span class="annot"><span class="annottext">_testbody1 :: [Char]
</span><a href="Data.Serde.Internal.ISyn.html#_testbody1"><span class="hs-identifier hs-var hs-var">_testbody1</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-181"></span><span>  </span><span class="annot"><span class="annottext">[[Char]] -&gt; [Char]
</span><span class="hs-identifier hs-var">unlines</span></span><span>
</span><span id="line-182"></span><span>    </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">[Char]
</span><span class="hs-string">&quot;.coerce&quot;</span></span><span class="hs-special">,</span><span>
</span><span id="line-183"></span><span>      </span><span class="annot"><span class="annottext">[Char]
</span><span class="hs-string">&quot;  mkpackdecls&quot;</span></span><span class="hs-special">,</span><span>
</span><span id="line-184"></span><span>      </span><span class="annot"><span class="annottext">[Char]
</span><span class="hs-string">&quot;  mkunpackdecls&quot;</span></span><span class="hs-special">,</span><span>
</span><span id="line-185"></span><span>      </span><span class="annot"><span class="annottext">[Char]
</span><span class="hs-string">&quot;&quot;</span></span><span class="hs-special">,</span><span>
</span><span id="line-186"></span><span>      </span><span class="annot"><span class="annottext">[Char]
</span><span class="hs-string">&quot;.derive&quot;</span></span><span class="hs-special">,</span><span>
</span><span id="line-187"></span><span>      </span><span class="annot"><span class="annottext">[Char]
</span><span class="hs-string">&quot;  Eq Ord Show Read&quot;</span></span><span class="hs-special">,</span><span>
</span><span id="line-188"></span><span>      </span><span class="annot"><span class="annottext">[Char]
</span><span class="hs-string">&quot;  Generic Typeable Data&quot;</span></span><span class="hs-special">,</span><span>
</span><span id="line-189"></span><span>      </span><span class="annot"><span class="annottext">[Char]
</span><span class="hs-string">&quot;&quot;</span></span><span class="hs-special">,</span><span>
</span><span id="line-190"></span><span>      </span><span class="annot"><span class="annottext">[Char]
</span><span class="hs-string">&quot;data Person&quot;</span></span><span class="hs-special">,</span><span>
</span><span id="line-191"></span><span>      </span><span class="annot"><span class="annottext">[Char]
</span><span class="hs-string">&quot;  age :: Int32 via Age&quot;</span></span><span class="hs-special">,</span><span>
</span><span id="line-192"></span><span>      </span><span class="annot"><span class="annottext">[Char]
</span><span class="hs-string">&quot;  name :: String via VerifyLength 1 10 String&quot;</span></span><span class="hs-special">,</span><span>
</span><span id="line-193"></span><span>      </span><span class="annot"><span class="annottext">[Char]
</span><span class="hs-string">&quot;  email :: String via VerifyEmail String&quot;</span></span><span class="hs-special">,</span><span>
</span><span id="line-194"></span><span>      </span><span class="annot"><span class="annottext">[Char]
</span><span class="hs-string">&quot;&quot;</span></span><span class="hs-special">,</span><span>
</span><span id="line-195"></span><span>      </span><span class="annot"><span class="annottext">[Char]
</span><span class="hs-string">&quot;newtype Age&quot;</span></span><span class="hs-special">,</span><span>
</span><span id="line-196"></span><span>      </span><span class="annot"><span class="annottext">[Char]
</span><span class="hs-string">&quot;  getage :: Int32&quot;</span></span><span class="hs-special">,</span><span>
</span><span id="line-197"></span><span>      </span><span class="annot"><span class="annottext">[Char]
</span><span class="hs-string">&quot;&quot;</span></span><span>
</span><span id="line-198"></span><span>    </span><span class="hs-special">]</span><span>
</span><span id="line-199"></span></pre></body></html>